#Google Borg
##概述
  Google的Borg系统是一个集群管理工具，在它上面运行着成千上万的job，这些job来自许许多多不同的应用，并且跨越多个集群，而每个集群又由大量的机器构成。
   
  Borg通过组合准入控制，高效的任务打包，超额负载以及基于进程级别性能隔离的机器共享从而实现高利用率。它支持那些高可用的应用，它们的运行时特性能够最小化错误恢复时间，它们的调度策略降低了相关错误发生的可能性。为了简化用户的使用，Borg提供了一个声明工作规范语言，名称服务一体化机制，实时job监控以及一系列用于分析和模拟系统行为的工具。

!["2.png"](https://github.com/survivorice/2018se-project1/blob/master/photo/2.png)
##简介
   这个我们内部叫做Borg的集群管理系统确认，调度，启动，重启以及监视Google运行的所有应用。Borg有三大优点：（1）它隐藏了资源管理以及错误处理，因此用户能集中精力开发应用； （2）具有非常高的可靠性和可用性，从而能够支持具有这些特性的应用；（3）能够让我们跨越数以千计的机器有效地运行负载。Borg并不是第一个解决这些问题的系统，但是它是少数能在这么大规模处理这些问题并且还能达到这样弹性和完整性的系统之一。

##特性
###工作负载
   Borg运行各种各样的负载，这些负载主要可以分为两类。第一类是长时间运行不能停止的服务并且要求能够处理短暂的，延迟敏感的请求（延迟要求在几微秒到几百毫秒之间）。这些服务主要用于面向终端用户的服务，例如Gmail，Google Docs，web搜索以及内部的一些基础设施服务（例如BigTable）。第二类是通常需要几秒到几天来完成的批处理job，这些job对短时间的性能波动并不是非常敏感。这些负载通常在cell之间混合分布，每个cell随着主要租户以及时间的不同会运行各种不同的应用：批处理类型的job来了又走而许多面向终端用户的job又期望一个能长时间使用的模式。Borg要求能很好地处理所有的情况。

###集群和cell
  一个cell中的机器通常属于单个集群，并且由数据中心规模的高性能网络结构连接起来。一个集群通常存在于单个数据中心里，而多个数据中心的集合构成了一个site。一个集群通常包含一个大的cell，也许其中还有一些小规模用于测试或者其他特殊目的的cell。我们总是极力避免单点故障发生

###job和task
Borg的一个job的属性通常包括它的名字，所有者以及它拥有的task的名字。job可以存在一定的约束，从而让它的task运行在有特定属性的机器上，例如特定的处理器架构，操作系统版本，以及外部IP。约束可以分为硬性的或软性的。软性的约束更像是一种优先建议而不是要求。一个job的运行可以推迟到上一个结束之后才开始并且一个job只能运行在一个cell中。
每个task代表了运行在一个容器或者一个物理机器内的一系列Linux进程。每个task同样拥有各自的属性，例如资源需求以及task在job里的索引。大多数task属性在同一个job里都是相同的，但是提供了针对具体task的命令行标志之后也能对它们进行重载。用户通常通过向Borg发送远程过程调用，即利用一些命令行工具，来操作job或者我们的监视系统。在一个正在运行的job中，用户可以通过推送一个新的job配置文件给Borg并且命令Borg更新task到新的配置，从而改变一些或者全部task的属性。

!["3.png"](https://github.com/survivorice/2018se-project1/blob/master/photo/3.png)

###allocs
Borg的alloc（allocation的简写）操作是指在一台机器上预留一些资源，从而能够在其上运行一个或者多个资源；这些资源不管是否被使用都是保持被分配状态的。Allocs操作可以被用来保留资源用于未来task的使用，也可以用于在停止以及启动一个task之间保存资源，还可以用于将不同job里的task收集起来，让它们运行在同一台机器中：比如一个web服务器实例以及相关的用于将本地磁盘的服务器URL记录拷贝到分布式文件系统的task。被alloc操作之后的资源和机器中的其他资源是被同等对待的，运行在同一个alloc操作之上的多个task共享其中的资源。如果一个alloc操作必须被重定向到另一台机器上，那么之上的任务就必须随着alloc操作被重新调度。一个alloc集就像是一个job：它是一系列的alloc操作用于在多台机器上预留资源。一旦一个alloc操作被创建，一个或多个job就能被提交并且运行在它之上。简单起见，我们一般用“task”来代之一次alloc操作或者顶层的task（一个在alloc操作之外的task），而“job”指一个job或者一个alloc操作集。

###优先级，配额以及准入控制
个job都有一个优先级（priority），也就是一个小的正整数。一个高优先级的task可以以牺牲另一个较低优先级的task为代价来获取资源，即使这种牺牲包括抢占或者杀死较低优先级的task。优先级用来表示在一个cell中运行或者等待运行的job的相对重要性。

###命名以及监控
 单单创造并且部署task还是远远不够的，因为一个服务的客户端以及其他系统需要能够找到它们，即使在它们被调度到新的机器上以后。因此，Borg为每个task创造了一个叫”Borg name service“(BNS)类型的名字，这个名字中包含了cell的名字，job的名字以及task的编号。Borg会将task的主机名，端口号以及这个BNS名字写入Chubby里面一个一致的，高可用的文件中，而这个文件通常被我们的RPC系统用于查找task。BNS名字同样被用作task的DNS名字基础，因此对于用户ubar拥有的一个在叫做cc的cell中的一个叫jfoo的job中的第五十个task，我们就可以通过域名50.jfoo.ubar.cc.borg.google.com访问到。同时Borg会在job的大小或者task的健康状况改变时将它们写入Chubby中，之后负载均衡器就能决定将请求路由到什么地方了。几乎Borg之下运行的每一个task都有一个内置的HTTP server用于发布task的健康状况以及其他许多的性能指标（RPC延迟等等）。Borg会监视健康检查的URL并且会重启那些没有即使回复的task或者直接返回一个HTTP 错误代码。其他数据通过另外一些监控工具进行监控，并且对服务对象级别的违规行为进行报警。Borg会记录所有的job提交情况，task事件，以及Infrastore中详细的task执行前的资源使用情况。